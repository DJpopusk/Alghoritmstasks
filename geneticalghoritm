#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
#include <ctime>

using namespace std;

struct Item {
    int weight;
    int value;
};

class GeneticKnapsackSolver {
private:
    struct Individual {
        vector<int> chromosome;
        int fitness = 0;
    };

    vector<Item> items;
    int capacity;
    int populationSize;
    int maxGenerations;
    double mutationRate;

    vector<Individual> initializePopulation() {
        vector<Individual> population(populationSize);
        for (int i = 0; i < populationSize; ++i) {
            population[i].chromosome.resize(items.size());
            for (size_t j = 0; j < items.size(); ++j) {
                population[i].chromosome[j] = rand() % 2;
            }
            calculateFitness(population[i]);
        }
        return population;
    }

    void calculateFitness(Individual& individual) {
        int totalWeight = 0;
        int totalValue = 0;
        for (size_t i = 0; i < individual.chromosome.size(); ++i) {
            if (individual.chromosome[i]) {
                totalWeight += items[i].weight;
                totalValue += items[i].value;
            }
        }
        individual.fitness = (totalWeight > capacity) ? 0 : totalValue;
    }

    Individual tournamentSelection(const vector<Individual>& population) {
        vector<Individual> candidates;
        for (int i = 0; i < 3; ++i) {
            candidates.push_back(population[rand() % population.size()]);
        }
        return *max_element(candidates.begin(), candidates.end(),
            [](const Individual& a, const Individual& b) {
                return a.fitness < b.fitness;
            });
    }

    void crossover(Individual& parent1, Individual& parent2) {
        int point = rand() % (parent1.chromosome.size() - 1);
        for (size_t i = point; i < parent1.chromosome.size(); ++i) {
            swap(parent1.chromosome[i], parent2.chromosome[i]);
        }
    }

    void mutate(Individual& individual) {
        for (size_t i = 0; i < individual.chromosome.size(); ++i) {
            if (static_cast<double>(rand()) / RAND_MAX < mutationRate) {
                individual.chromosome[i] = 1 - individual.chromosome[i];
            }
        }
    }

public:
    struct Result {
        int bestValue;
        int totalWeight;
        vector<int> bestChromosome;
    };

    GeneticKnapsackSolver(const vector<Item>& items, int capacity,
                        int populationSize = 50, int maxGenerations = 200,
                        double mutationRate = 0.05)
        : items(items), capacity(capacity), populationSize(populationSize),
          maxGenerations(maxGenerations), mutationRate(mutationRate) {}

    Result solve() {
        vector<Individual> population = initializePopulation();

        for (int gen = 0; gen < maxGenerations; ++gen) {
            vector<Individual> newPopulation;

            sort(population.begin(), population.end(),
                [](const Individual& a, const Individual& b) {
                    return a.fitness > b.fitness;
                });
            newPopulation.push_back(population[0]);
            newPopulation.push_back(population[1]);

            while (newPopulation.size() < populationSize) {
                Individual parent1 = tournamentSelection(population);
                Individual parent2 = tournamentSelection(population);
                
                Individual child1 = parent1;
                Individual child2 = parent2;
                
                crossover(child1, child2);
                mutate(child1);
                mutate(child2);
                
                calculateFitness(child1);
                calculateFitness(child2);
                
                newPopulation.push_back(child1);
                if (newPopulation.size() < populationSize) {
                    newPopulation.push_back(child2);
                }
            }
            population = newPopulation;
        }

        sort(population.begin(), population.end(),
            [](const Individual& a, const Individual& b) {
                return a.fitness > b.fitness;
            });

        Result result;
        result.bestValue = population[0].fitness;
        result.bestChromosome = population[0].chromosome;
        
        result.totalWeight = 0;
        for (size_t i = 0; i < result.bestChromosome.size(); ++i) {
            if (result.bestChromosome[i]) {
                result.totalWeight += items[i].weight;
            }
        }

        return result;
    }
};

int main() {
    ifstream input("ks_19_0");
    if (!input) {
        cerr << "Error: Failed to open file" << endl;
        return -1;
    }

    srand(static_cast<unsigned>(time(nullptr)));

    int N, CAP;
    input >> N >> CAP;
    vector<Item> items(N);
    for (int i = 0; i < N; ++i) {
        input >> items[i].weight >> items[i].value;
    }
    input.close();

    GeneticKnapsackSolver solver(items, CAP);
    auto result = solver.solve();

    cout << "Best Profit: " << result.bestValue << endl;
    cout << "Total Weight: " << result.totalWeight << endl;
    cout << "Items to include: ";
    for (size_t i = 0; i < result.bestChromosome.size(); ++i) {
        if (result.bestChromosome[i]) {
            cout << i + 1 << " ";
        }
    }
    cout << endl;

    return 0;
}
